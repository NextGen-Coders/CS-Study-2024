## 🎾 1. index란?

<img width="394" alt="image" src="https://github.com/NextGen-Coders/CS-Study-2024/assets/76567238/0b475788-13b1-4600-aaae-4fbc4a35e6db">

위 제품은 인덱스 탭입니다.  여려분이 제품을 언제 사용하시나요?
맞습니다.  두꺼운 책을 공부할 때 특정 내용을 바로 가기 위해서 붙이죠
인덱스의 사전적 정의는 '책 속의 내용 중에서 중요한 단어나 항목, 인명 따위를 쉽게 찾아볼 수 있도록 일정한 순서에 따라 별도로 배열하여 놓은 목록'이라고 합니다. 
여기서 중요한 것은 `일정한 순서에 따라 별도로 배열하여 놓은 목록`입니다.  

<br>

## 🎾 2. index는 왜 필요할까요?

<img width="737" alt="image" src="https://github.com/NextGen-Coders/CS-Study-2024/assets/76567238/77bb4f66-42ad-429b-9876-a43ad7a0c98c">

여기는 수원 별마당 도서관입니다.  여기서 10분안에 특정 도서를 찾으라고 한다면  바로 찾을 수 있으신가요?
아니면 더 큰 도서관이면 어떻게 하시겠습니까?  
실제로 우리가 가정 먼저 할 일은 도서관의 색인에 대한 액세스를 요청하는 것입니다. 색인에는 항목에 빠르고 효율적으로 액세스하는 데 필요한 모든 정보가 포함되어 있기 때문입니다.  

동일한 방식으로 데이터베이스 인덱스에는 데이터에 빠르고 효율적으로 액세스하는 데 필요한 모든 정보가 포함되어있습니다. 현대 사회에서 데이터 비즈니스는 빠르게 발전하고 있습니다.  실제로 일부 거대 기술 기업에서는 하루에 수백 페타바이트의 데이터를 처리합니다. 이 모든 데이터를 데이터베이스에 저장하는 것은 좋지만 데이터 회사의 경우 해당 데이터에 효울적으로 액세스할 수 잇는 것이 성공의 가장 중요한 요소입니다. 의회 도서관의 예와 마찬가지로 대량의 데이터에 대한 액세스 문제를 해결하는 한 가지 방법은 색인을 사용하는 것 입니다.  


<br>

## 🎾 3. 인덱스가 생성되는 과정

데이터베이스에서 데이터는 테이블로 구성된 행에 저장됩니다. 각 행에는 다른 모든 행과 구별되는 고유 키가 있으며 해당 키는 빠른 검색을 위해 인덱스에 저장됩니다. 

키는 인덱스에 저장되므로 고유 키가 있는 새 행이 추가될 때마다 인덱스가 자동으로 업데이트됩니다. 그러나 때로는 키로 저장되지 않은 데이터를 빠르게 조회할 수 있어야 하는 경우도 있습니다. 예를 들어 전화번호로 고객을 신속하게 검색해야 할 수도 있습니다. 동일한 전화번호를 가진 여러 고객이 있을 수 있으므로 고유 제약 조건을 사용하는 것은 좋은 생각이 아닙니다. 이러한 경우 자체 색인을 만들 수 있습니다.

덱스를 생성하는 구문은 데이터베이스에 따라 다릅니다. 그러나 구문에는 일반적 CREATE으로 키워드, INDEX키워드 및 인덱스에 사용하려는 이름이 포함됩니다. 그 다음에 ON는 키워드와 빠르게 액세스하려는 데이터가 있는 테이블 이름이 와야 합니다 . 마지막으로 명령문의 마지막 부분은 인덱싱할 열의 이름이어야 합니다.

```
CREATE INDEX <index_name>
ON <table_name> (column1, column2, ...)
```


<br>

## 🎾 4. 인덱스의 장점

1) 조건 검색 where 절의 효율성
테이블을 만들고 안에 데이터가 쌓이게 되면 테이블의 레코드(row : 행)는 내부적으로 순서가 없이 뒤죽박죽으로 저장이 됩니다. 이렇게 되면 WHERE절에 특정 조건에 맞는 데이터들을 찾아낼 때도 레코드의 처음부터 끝까지 다 읽어서 검색 조건과 맞는지 비교해야 합니다.  이것을 풀 스캔(Full Scan)이라고 합니다. 반면에 인덱스 테이블 스캔(Index Table Scan) 시 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 해당 조건(WHERE)에 맞는 데이터들을 빠르게 찾아낼 수 있습니다.

2) 

인덱스를 사용하면 ORDER BY에 의한 정렬(Sort) 과정을 피할 수 있습니다(ORDER BY는 굉장히 부하가 많이 걸리는 작업입니다.) 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면 디스크 I/O도 추가적으로 발생되기 때문입니다. 하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 된다. 그 이유는 이미 정렬이 되어 있기 때문에 가져오기만 하면 되기 때문입니다.

## 🎾 5. 인덱스의 단점

1) DML에 취약

INSERT, UPDATE, DELETE를 통해 데이터가 추가되거나 값이 바뀐다면 인덱스 테이블 내에 있는 값들을 다시 정렬을 해야 합니다. 그리고 위에 사진처럼 인덱스 테이블, 원본 테이블 이렇게 두 군데의 데이터 수정 작업을 해줘야 한다는 단점도 발생합니다.  그렇기 때문에 DML이 빈번한 테이블보다 검색을 위주로 하는 테이블에 인덱스를 생성하는 것이 좋습니다.

2) 상황에 맞게 사용하지 않으면 독

검색을 위주로 하는 테이블에 인덱스를 생성하는 것이 좋지만 무조건 검색 시에도 인덱스가 좋은 것은 아닙니다. 인덱스는 테이블의 전체 데이터 중에서 10~15% 이하의 데이터를 처리하는 경우에만 효율적이고 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 좋습니다. 직관적인 예시를 들자면 1개의 데이터가 있는 테이블과 100만 개의 데이터가 들어 있는 테이블이 있다고 한다면  100만 개의 데이터가 들어있는 테이블이라면 풀 스캔보다는 인덱스 스캔이 유리하겠지만, 1개의 데이터가 들어있는 테이블은 굳이 인덱스 스캔 없이 풀 스캔이 빠릅니다.

3) 속도 향상을 위해 인덱스를 많이 만드는 것은 좋지 않습니다.

인덱스를 관리하기 위해서는 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요합니다. 무턱대고 인덱스를 만들어서는 결코 안 됩니다.  즉, 속도 향상에 비해 단점들의 COST를 비교해서 인덱스를 만들지 말지를 정해야 좋습니다.

<br>

## 🎾 6. 인덱스 구조

인덱스에는 여러 가지 유형이 있지만 그중에서도 가장 많이 사용하는 인덱스의 구조는 밸런스드 트리 인덱스 구조입니다. 그리고 B TREE 인덱스 중에서도 가장 많이 사용하는 것은 B*TREE와 B + TREE구조가 가장 많이 사용되는 인덱스 구조입니다.

<img width="1015" alt="image" src="https://github.com/NextGen-Coders/CS-Study-2024/assets/76567238/bfb5c9b9-f63e-425c-ab0d-b7c01559e481">

<출처 : DBA 커뮤니티 구루비>

B*TREE 인덱스는 대부분의 DBMS 그리고 오라클에서 특히 중점적으로 사용하고 있는 가장 보편적인 인덱스입니다.구조는 위와 같이 Root(기준) / Branch(중간) / Leaf(말단) Node로 구성되며 계층적 구조를 갖고 있습니다.  특정 컬럼에 인덱스를 생성하는 순간 컬럼의 값들을 정렬하는데, 오라클 서버에서 풀 스캔보다 인덱스 스캔이 유리하다고 판단되었을 때 생성된 인덱스의 정렬한 순서가 중간쯤 되는 데이터를 뿌리에 해당하는 ROOT 블록으로 지정하고 ROOT 블록을 기준으로 가지가 되는 BRANCH블록을 정의하며 마지막으로 잎에 해당하는 LEAF 블록에 인덱스의 키가 되는 데이터와 데이터의 물리적 주소 정보인 ROWID를 저장합니다.


<br>
<br>

---

### 📚 Reference

- [DB index 입문](https://tecoble.techcourse.co.kr/post/2021-09-18-db-index/)
- [[Database] 인덱스](https://velog.io/@hwaya2828/Database-Index)
- [db_index](https://github.com/devSquad-study/2023-CS-Study/blob/main/DB/db_index.md)
- [[10분 테코톡] 👨‍🏫안돌의 INDEX](https://www.youtube.com/watch?v=NkZ6r6z2pBg&t=363s)
