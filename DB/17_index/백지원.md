# Index

## 📖목차
1. 정의
2. 관리
3. 장단점
4. 어느 경우에 사용하는가
5. 인덱스(Index)의 자료구조

## ⛵인덱스란

만약 우리가 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾아 보는것은 오랜 시간이 걸립니다. 그렇기 때문에 책의 저자들은 책의 왼쪽 아래 또는 오른쪽 아래에 index를 추가하는데, 데이터베이스의 index도 이와 같습니다.
데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 `데이터의 위치를 포함한 자료구조`를 생성하여 빠르게 조회할 수 있도록 돕고 있습니다.

<br>

## 🚂인덱스의 관리

인덱스는 항상 최신 데이터를 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있습니다. 따라서 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며, 그에 따른 오버헤드가 발생합니다.
 

INSERT : 새로운 데이터에 대한 `인덱스를 추가`한다.
DELETE : `삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행`한다.
UPDATE : `기존의 인덱스를 사용하지 않음 처리`하고, `갱신된 데이터에 대해 인덱스를 추가`한다.

<br>

## 🛟인덱스의 장단점
 
### 👍장점

1. 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
2. 중복 데이터를 방지하거나 특정 컬럼의 유일성(Unique)을 보장할 수 있다.
3. ORDER BY 절과 GROUP BY 절, WHERE 절 등이 사용되는 작업이 더욱 효율적으로 처리된다.

 
### 👎단점

1. 인덱스 생성에 따른 추가적인 저장 공간이 필요하다. (인덱스 사용 시 해당 정보를 담은 MYI 파일 생성)
2. CREATE(삽입), DELETE(삭제), UPDATE(수정) 작업 시에도 인덱스를 업데이트해야 하므로 성능 저하가 발생할 수 있다.
3. 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
4. 인덱스 생성 시간이 오래 걸릴 수 있다.
5. 인덱스를 잘못 사용할 경우, 오히려 성능이 저하되는 역효과가 발생할 수 있다. 

만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있습니다. 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문입니다. 이는 UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해주기 때문인데, 만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 훨씬 많이 존재하게 되기 때문입니다.

따라서 인덱스를 사용하는 것 만큼이나 생성된 인덱스를 관리해주는 것도 중요합니다. 그러므로 사용되지 않는 인덱스는 바로 제거를 해주어야 합니다.

## 🐙인덱스를 사용하는 경우

1. 대량의 데이터 검색
<br>대량의 데이터를 전체 스캔하는 것은 매우 느리고 부하가 발생하기 때문에 이 경우에 인덱스를 사용하여 검색하는 것이 효율적입니다.
 
2. 정렬된 결과 출력
<br>인덱스를 사용하여 데이터를 정렬하면 매우 빠르게 정렬된 결과를 출력할 수 있습니다.
 
3. 조인 연산 수행
<br> 데이터베이스에서 조인(join)은 두 개 이상의 테이블을 결합하여 필요한 정보를 가져오는 작업을 말합니다. 이때 인덱스를 사용하면 연산 속도를 향상시킬 수 있습니다.
 
4. 유니크한 값을 가져오는 경우
<br> 인덱스는 유니크한 값을 가지고 있는 필드에 대해 중복되지 않는 값을 빠르게 검색할 수 있습니다. 이러한 경우 인덱스를 사용하여 검색 속도를 빠르게 할 수 있습니다.
 
5. 검색 빈도가 높은 경우
<br> 검색 빈도가 높은 필드에 대해서 인덱스를 생성하여 검색 속도를 향상시키는 것이 좋습니다. 자주 검색되는 필드에 인덱스를 적용하면 검색 작업이 빠르고 효율적으로 수행됩니다.

## 🍨인덱스(Index)의 자료구조

### 1. 해시 테이블(Hash table)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FRpMoO%2FbtqKMzdg9TX%2FXYkGt2kqE0hr9rqhHx3o3K%2Fimg.png)

해시 테이블은 키(Key)와 해시 값(Hash Value) 쌍으로 이루어진 자료구조이다. O(1)의 시간복잡도를 가지고 있어 상당히 빠른 검색을 할 수 있는 것이 특징이다.
 
해시 테이블의 검색 방식은 키를 해시 함수를 사용하여 해시 값으로 변환한 후, 해당 해시 값에 해당하는 값을 찾아서 검색한다. 해시 테이블은 검색 속도가 매우 빠르지만, 데이터의 분포에 따라 충돌이 발생할 수 있다. 따라서 충돌을 해결하기 위한 방법이 필요하다.

### 2. B-Tree

B-트리는 데이터베이스에서 널리 사용되는 인덱스 자료구조 중 하나입니다. 이는 O(logN)의 시간 복잡도를 가지고 있어 데이터베이스에서 검색 속도를 향상시키는 데 사용됩니다.

B-트리의 각 노드에 있는 데이터는 항상 정렬된 상태를 유지합니다. 이 특징으로 인해 데이터와 데이터 사이의 범위를 이용하여 자식 노드를 가집니다. 각 노드는 여러 개의 키를 가질 수 있으며, 각 키는 해당하는 데이터를 가지고 있습니다. 노드마다 자식 노드의 개수는 키의 개수보다 하나 더 많습니다.

이와 같은 특성들로 인해 B-트리는 데이터베이스에서 매우 효율적으로 사용됩니다.
 
### 3. B+Tree

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd78iJ0%2FbtqKRYbLdM9%2FnIvz1M4gffMl4YHS77JSfK%2Fimg.png)

B+ 트리는 B 트리의 변형된 구조로, 기본적으로 B 트리와 유사하지만 몇 가지 차이점을 가지고 있습니다. B+ 트리 역시 균형 잡힌 이진 검색 트리입니다. 그러나 B 트리와 비교하여 더 많은 키를 저장할 수 있는 특징을 가지고 있습니다.

B+ 트리는 B 트리와 달리 내부 노드와 단말 노드로 명확히 구분됩니다. 이때 모든 데이터는 단말 노드에만 저장되고, 내부 노드에는 검색을 위한 인덱스만 저장됩니다.

모든 리프 노드는 연결 리스트로 연결되어 있으며, 순차적으로 데이터가 저장됩니다. 이 특징으로 인해 범위 검색이나 순차 검색과 같은 작업에 매우 효율적입니다

---

### 📌 Reference  

- [[Database] 인덱스(index)란?](https://mangkyu.tistory.com/96)

- [[DB] 데이터베이스 인덱스(index) 개념 정리](https://ittrue.tistory.com/331)

- [[MySQL] B-Tree로 인덱스(Index)에 대해 쉽고 완벽하게 이해하기](https://mangkyu.tistory.com/286)

- [[Database] Index(인덱스) 란?](https://k39335.tistory.com/26)

- [[DB/자료구조] B-Tree(B트리), B+트리](https://potatoggg.tistory.com/174)