# HTTP 진화 과정 (HTTP/1.0부터 HTTP/3까지) 

## 🔎HTTP는 무엇인가

http의 변천사를 알아보기 전에, http가 무엇인지를 먼저 알아보겠습니다.

>HTTP(HyperText Transfer Protocol)는 World Wide Web 상에서 정보를 주고받을 수 있는 프로토콜이다. 주로 HTML 문서를 주고받는 데에 쓰인다. <br> - 위키피디아 -

위 문장을 풀어서 해석해보면, 다음과 같이 이해해볼 수 있습니다.<br> HTTP는 하이퍼텍스트(HyperText)를 전송하는(Transfer) 프로토콜(Protocol)이고, 전송이 이루어지는 장소는 World Wide Web이다.

이 정의를 제대로 이해하기 위해서 아래 세 단어에 대해서 이해해보도록 하겠습니다.
- HyperText
- Protocol
- World Wide Web

### HyperText
하이퍼텍스트란 다른 문서에 대한 참조를 통해 독자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트를 말합니다. HTML 상에서 < a > 라는 요소를 사용할 때, 저희는 다른 문서로 이동할 수 있는데, 이렇게 이동할 수 있는 텍스트를 하이퍼텍스트라고 말합니다.

![](https://velog.velcdn.com/images/yesbb/post/703a1054-7c41-4cf4-9e14-a024e1423276/image.jpeg)

사진과 같이, 하이퍼텍스트를 통해서 다양한 문서사이를 왔다갔다 할 수 있습니다. 기존의 문서는 위에서 아래로 순차적이면서 서열적인 구조를 갖추고 있었지만, 하이퍼텍스트는 문서 내에 삽입된 링크에 의해서 그 차례가 바뀌면서 임의적이고 나열적인 구조를 가지게 됩니다.

보통 이런 하이퍼텍스트를 사용하고 있는 대표적인 기술이 HTML입니다. HTTP 초창기에는 HTML만 지원가능했지만, 최근에는 거의 모든 파일 형식을 HTTP를 통해서 지원할 수 있게 되었습니다.

HyperText의 정의를 알아봄으로써 HTTP가 전송하는 대상이 무엇인지 알 수 있었습니다. HTTP가 전송하는 대상은 HyperText였으나, 최근에는 거의 모든 파일을 HTTP를 통해서 전송할 수 있게 되었습니다.

### Protocol
>프로토콜은 컴퓨터 내부에서, 또는 컴퓨터 사이에서 `데이터의 교환 방식`을 정의하는 규칙 체계입니다. <br> - MDN -

프로토콜은 저희가 사용하는 언어와 비슷합니다. 한국인은 한국인끼리 그들이 가지고 있는 생각(데이터)를 전달하기 위해서 한국어라는 프로토콜을 사용합니다. 만약 서로가 사용하는 언어, 즉 프로토콜이 다르다면 정보를 공유하기 어려워집니다.

이처럼 컴퓨터 사이에서도 정보를 공유하기 위해 프로토콜이라는 규칙을 맞출 필요가 있습니다.이 프로토콜을 통해서 컴퓨터는 다른 컴퓨터와 의사소통을 할 수 있게 됩니다.

### World Wide Web
>월드 와이드 웹은 인터넷에 연결된 컴퓨터를 통해 사람들이 정보를 공유할 수 있는 전세계적인 정보 공간을 말한다. 간단히 웹이라고 부르는 경우가 많다. <br> - 위키피디아 -

간단히 말하면, 컴퓨터를 통해 정보를 공유하는 정보공간 입니다.

![](https://velog.velcdn.com/images/yesbb/post/7e96d463-514b-4fb3-bed8-695d2c05ecdc/image.jpeg)

1989년 스위스와 프랑스 사이에는 CERN(유럽 입자 물리 연구소)라는 곳이 있었습니다.
이 연구소에 팀 버너스 리 라는 컴퓨터 과학자가 있었습니다. 팀 버너스 리는 세계의 여러 대학과 연구기관에서 일하는 물리학자들 사이에서 신속하게 정보를 교환하고, 효율적으로 공동연구를 진행할 수 있는 방안을 고민했습니다. 그러다 탄생하게 된 것이 바로 World Wide Web입니다.

### WWW 구성 요소

이 WWW는 기존의 TCP와 IP 프로토콜 상에서 만들어지면서, 4개의 구성요소를 가지게 되었습니다.

- HTML : 하이퍼텍스트 문서를 표현하기 위한 텍스트 형식
- HTTP : 문서 같은 것을 교환하기 위한 간단한 프로토콜
- 브라우저 : 문서를 화면에 보여주기 위한 클라이언트
- httpd : 문서에 접근하도록 해주는 httpd의 초기버전 (아파치 하이퍼텍스트 전송 프로토콜 서버)

이 4가지 구성요소들은 1990년 말에 완료되었습니다. 본격적으로 HTTP의 변천사를 알아보기 위해 먼저, 가장 초창기버전인 HTTP/0.9를 알아보겠습니다.

## HTTP/0.9 - The First Step
사실 HTTP/0.9 버전은 출시될 때부터 0.9 버전이라는 이름을 가진 것은 아닙니다. HTTP/0.9 이후 버전들이 생기면서, 이전과 구분하기 위해서 버전이름이 붙여진 것입니다.

0.9버전은 단순합니다. 이용가능한 메서드는 오직 GET 하나밖에 없고, 단 한줄의 요청으로 구성됩니다.

요청 메시지의 예시) `메서드(오직 GET) + 경로 형식`

```
GET /mypage.html
```

응답 또한 단순합니다. 오직 HyperText만 지원했습니다.

```
<HTML>
A very simple HTML page
<HTML>
```

응답을 주고나면, 곧바로 연결이 제거되었습니다. 헤더도 존재하지 않았고, 상태코드, 버저닝 같은것들 또한 존재하지 않았습니다. 헤더가 존재하지 않았다는 것은 `오직 HTML 파일만 전송`할 수 있었다는 것을 의미합니다. 헤더가 등장함으로써 다양한 종류의 파일을 지원할 수 있었던 것입니다. HTTP/0.9까지는 매우 단순한 프로토콜이었습니다.

## HTTP/1.0 - Expanding Capabilities
HTTP/1.0에선 몇가지 추가적인 변화가 생깁니다.

>1. 버저닝
>2. 상태코드
>3. 헤더
>4. 메서드 확장

### 1.버저닝
 요청을 보낼 때마다 버전 정보가 붙습니다. 
 
 예시)
 ```
 GET /mypage.html HTTP/1.0 
 ```

### 2.상태코드 :
응답의 시작 부분에 붙어서 전송됩니다. 이 덕분에 브라우저는 요청에 대한 성공 및 실패 여부를 알 수 있습니다.
 ```
200 OK
Date : Tue, 15 nov 1994 08:12:31 GMT 
...
 ```

### 3.헤더 :
요청과 응답에 대한 메타데이터를 전송할 수 있게 해줍니다.
이는 HTML만 지원 가능하던 제한적 상황을 극도로 유연하고 확장 가능하게 만들어주었습니다. 여타 스타일시트, 스크립트, 미디어 파일등을 지원할 수 있게 되었습니다. <br>
(헤더 안에서도 Content-Type 덕분입니다.)

`메타데이터 : 데이터에 관한 구조화된 데이터로, 다른 데이터를 설명해 주는 데이터 [위키피티아]`

### 4.메서드 확장 :
0.9에서는 GET만 지원했으나, 1.0에서는 `GET`, `HEAD`, `POST`를 지원합니다.

### HTTP/1.0에 남아있던 한계
바로 연결입니다. 0.9버전과 마찬가지로 response가 보내지고 나면 연결이 제거되었습니다.

매번 요청와 응답 사이에 단 하나의 연결만이 존재했습니다. 응답이 끝나면 연결이 사라지고, **다음번 요청을 하기 위해서는 다시 3-way-handshake를 통해서 TCP 커넥션을 생성해주어야** 했습니다.

1.0버전은 뭔가 합의를 해서 만들어진 버전이 아니고, 일단 생겨나는 문제들을 뭐든지 해결해보자. 라는 방식으로 접근하며 발전되었습니다.

## HTTP/1.1 - The Standard Protocol

 HTTP/1.1 버전은 표준이 된 이후로 현재까지도 이용되고 있습니다. HTTP/1.0이 정의되어가는 와중에도 HTTP의 표준화를 위한 다양한 작업들이 동시다발적으로 진행되어, HTTP/1.0이 발표된 지 몇 달이 채 지나지 않아 발표되었습니다.

다음의 사항들이 1.1버전에서 생긴 중대한 변화들입니다.

1. 연결 재사용 : 이전에 사용된 연결을 다시 열어 시간을 절약합니다.
2. 파이프라이닝 : 명령어의 데이터 경로를 세분화하고, 각기 다른 세부 단계를 동시에 수행하게 함으로써, 여러 명령어들을 중첩 수행 가능하게 합니다. 이로 인해 첫번째 요청의 응답이 완전히 전송되기 전에 두번째 요청 전송이 가능해지고, 커뮤니테이션 latency 낮추었습니다.

`latency : 일반적으로 요청과 응답 사이의 시간을 말함.`

3. 청크 가능한 응답 : 뭉텅이진 응답을 나누어 보낼 수 있습니다.
4. 캐시 제어 메커니즘 : 캐시 제어에 대한 세심한 컨트롤이 가능합니다.
5. 언어, 인코딩 및 타입을 포함한 컨텐츠 협상 : 클라이언트와 서버로 하여금 교환하기에 가장 적합한 컨텐츠를 보여줄 수 있습니다.
6. Host 헤더 지원 : 덕분에 동일 IP주소에서 다른 도메인을 호스트하는 기능이 서버 코로케이션을 가능하게 했습니다.
8. 다양한 메서드 지원 :
GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS
메서드를 지원합니다.

## HTTP/2 (HTTP over SPDY) - Improved Performance 

HTTP/1.1이 발표된 1997년 이후로 HTTP는 꾸준히 확장되었고, 그 사이 웹은 더욱 복잡해졌습니다. 그러다 보니 HTTP/1.1만으로는 극복할 수 없는 한계점이 점점 드러나기 시작했고, 이 점을 보완한 HTTP/2가 등장하게 되었습니다.

### HTTP/1.1의 문제점

1. 헤더의 중복
HTTP/1.1에 다양한 기능이 추가되면서 헤더에도 많은 메타 데이터가 담기게 되었습니다. 하지만 매 요청마다 헤더를 중복해서 전송해야만 했는데, 심지어는 전송하려는 값보다 헤더의 크기가 더 큰 경우도 종종 발생한다는 점입니다.

2. HOLB(Head-of-Line Blocking)
하지만 무엇보다도 가장 큰 문제는 서버가 항상 `요청받은 순서대로 응답`해야 하기 때문에 발생하는 HOLB(Head-of-Line Blocking) 문제였습니다. HTTP/1.1에서는 하나의 연결 내에서 응답 다중화(multiplexing) 를 할 수 없었기 때문에 요청이 순차적으로 처리되어야 했는데, 서버가 응답을 작성하던 중간에 문제가 생기면 후속 요청들이 전송되지 못하고 지연되는 문제가 있었습니다.

HTTP/1.1 방식에서는 이러한 문제는 물리적인 TCP 연결을 여러 개 두는 방식으로 병렬 연결을 구현해 해결하려 하였습니다. 브라우저마다의 정책도 다른데 일반적으로 최대 6개의 동시 TCP 연결을 지원한다는 것으로 알려져 있죠. 하지만 이 방식 역시 임시적인 해결책일 뿐 HTTP/1.1의 HOLB를 해결할 수 있는 해결책은 아니었습니다.

이 외에도 요청 별 우선순위를 지정할 수 없고, 클라이언트 기반 통신이기 때문에 서버에서 클라이언트 측으로 데이터를 전송할 수 있는 기능이 없다는 등의 문제가 있었습니다.

이러한 한계를 극복하기 위해 2015년 HTTP/2가 국제 표준으로 등장했습니다.

## HTTP/2 핵심 특징과 변화

1. 이진 프로토콜 사용<br>
HTTP/2는 이진(binary) 프로토콜을 사용하여 데이터를 바이너리로 인코딩합니다.
이전 버전인 HTTP/1.1이 텍스트 기반 프로토콜이었던 것과 달리, HTTP/2는 효율적인 데이터 전송을 위해 바이너리 프레이밍을 사용합니다.

2. 응답 다중화 지원<br>
HTTP/2는 하나의 TCP 연결에서 여러 요청을 동시에 처리할 수 있습니다.
이는 스트림(stream), 메시지(message), 프레임(frame)이라는 단위로 더 세분화되어 구현됩니다.
이 기능 덕분에 HTTP/1.1에서의 HOLB(Head-Of-Line Blocking) 문제를 해결했습니다.

3. HPACK을 통한 헤더 필드 압축<br>
HTTP/2는 HPACK이라는 허프만 코딩 기법을 사용하여 헤더 필드를 압축합니다.
이를 통해 변경되지 않은 헤더 정보는 재전송하지 않고 오버헤드를 최소화합니다.

4. 추가 기능들<br>
**서버 푸시(Server Push)**: 클라이언트의 요청 없이도 서버가 미리 리소스를 보낼 수 있습니다.<br>
**스트림 우선순위 지정**: 정수와 트리 구조를 사용하여 스트림별 우선순위를 지정합니다.<br>
**프로토콜 자체의 흐름 제어 기능**: 네트워크 트래픽 관리 및 제어를 위한 기능을 포함합니다.

## HTTP/3 (HTTP over QUIC) - The Future Step

### HTTP/3 등장 배경

HTTP/3는 TCP의 한계, 특히 HOLB(Head-Of-Line Blocking) 문제와 느린 연결 속도를 해결하기 위해 개발되었습니다.
TCP의 복잡한 기능 대신, UDP 기반의 QUIC 프로토콜을 사용함으로써 성능을 개선합니다.

### QUIC 프로토콜의 특징

QUIC은 UDP 기반으로, 신뢰성 있는 데이터 전송을 위해 필요한 기능들을 직접 구현합니다.
연결의 신속성과 신뢰성을 향상시키기 위해 0-RTT 및 1-RTT 연결 설정을 제공합니다.

### HTTP/3 특징

1. 독립적인 스트림 운영<br>
HTTP/3는 각 스트림이 독립적으로 운영되어, 하나의 스트림에 문제가 발생해도 다른 스트림에 영향을 주지 않습니다.

2. 연결 식별 및 유지의 개선<br>
연결 ID를 이용해 IP 변경에도 연결을 유지할 수 있어, 네트워크 환경 변화에 강합니다.

3. 향상된 보안 및 기능<br>
TLS 연결 설정이 내부적으로 포함되어 있어, 보안이 강화되었습니다.
우선순위 제어, 서버 푸시 등의 기능이 지원됩니다.

4. 헤더 압축 기법의 개선<br>
HTTP/3는 QPACK을 사용하여 헤더를 압축하고, QUIC의 독립적인 스트림 속성에 맞게 헤더 압축 기법을 최적화합니다.

5. TCP와의 호환성 및 전환<br>
기존 HTTP 체계와의 호환성을 지니며, 서버가 클라이언트에게 HTTP/3의 지원 여부를 알려주어 통신 방식을 전환할 수 있습니다.
이러한 HTTP/3의 특징들은 현대 인터넷 환경에서 요구되는 빠른 속도, 신뢰성, 효율성을 제공합니다.


## HTTP 버전 확인 방법

![](https://velog.velcdn.com/images/qorjiwon/post/4484faa8-87b0-4d88-98c9-a9a8ccd6946d/image.png)

위 사진에서 프로토콜 컬럼을 살펴보면 http/1.1, h2, h3이 적힌 것을 확인할 수 있습니다. 이는 각 통신이 HTTP/1.1, HTTP/2, HTTP/3를 이용했다는 것을 의미합니다.

---

### 📌 Reference  

- [MDN HTTP 진화](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP)

- [[요즘IT] 웹 개발자라면 알고 있어야 할 HTTP의 진화 과정](https://yozm.wishket.com/magazine/detail/1686/)

- [Introduction to HTTP/2](https://web.dev/performance-http2/)

- [HTTP3까지 버전별 변천사](https://velog.io/@yesbb/HTTP3%EA%B9%8C%EC%A7%80-%EB%B2%84%EC%A0%84%EB%B3%84-%EB%B3%80%EC%B2%9C%EC%82%AC)

- [풀스택서비스네트워킹 (Kyung Hee University, Dr.Sungwon Lee)](https://www.youtube.com/playlist?list=PLz7S5PHCu4OmWm8nUAFhc3x8RvbreFOyJ)