# HTTP 진화 과정 (HTTP/1.0부터 HTTP/3까지) 

![](https://velog.velcdn.com/images/qorjiwon/post/4484faa8-87b0-4d88-98c9-a9a8ccd6946d/image.png)

HTTP의 버전은 브라우저 개발자 도구의 네트워크 탭을 열어서도 쉽게 확인할 수 있습니다. 위 사진의 프로토콜 컬럼을 살펴보면, http/1.1, h2, h3이 적힌 것을 확인할 수 있죠. 이는 각 통신이 HTTP/1.1, HTTP/2, HTTP/3를 이용했다는 것을 의미합니다.


그런데 하나의 웹 사이트에서 왜 이렇게 다른 버전의 HTTP가 사용되고 있는 걸까요? 각 버전에는 무슨 차이가 있는 걸까요? 왜 HTTP의 버전은 1, 2, 3으로 딱 나누어 떨어지지 않을까요? 그래서 오늘은 HTTP의 각 버전이 등장하게 된 배경과 버전 별 특징을 정리해보고자 합니다. 이번 글을 통해 HTTP의 각 버전에 대해 자세하게 알고 싶은 분 들게 도움이 되기를 바랍니다.

## 표준 이전의 HTTP

HTTP의 버전이 1, 2, 3으로 딱 떨어지는 것이 아니기 때문에, HTTP/1.1이라는 숫자에 의문을 가지시는 분이 계실 수도 있을 것 같습니다. 사실 HTTP/1.1 전에는 HTTP/1.0과 HTTP/0.9라는 두 개의 버전이 더 있었습니다.

 

이번 글에서는 표준 이전의 HTTP라고 뭉뚱그려 이야기해 볼 건데요. 표준 이전의 HTTP 등장 배경을 먼저 요약하자면 다음과 같습니다.

> HTTP/0.9: 문서화된 최초의 HTTP 버전
HTTP/1.0: 기존 HTTP의 기능을 확장한 버전
HTTP/1.1: 표준화된 HTTP

따라서 HTTP/1.1을 알기 위해서는 표준 이전의 HTTP에 대해서도 알아야 합니다. 초창기 HTTP에 대해 이야기하려면 월드 와이드 웹(World Wide Web, 이하 웹)에 대한 이야기를 또 하지 않을 수가 없네요.

 

다들 아시겠지만 웹은 1990년대 초반 팀 버너스리가 제안한 인터넷 기반의 시스템입니다. 일반적으로 HTTP라는 프로토콜을 이용해 HTML 파일을 주고받을 수 있는 공간을 의미하죠.

 

초창기 웹은 아주 단순한 서버-클라이언트 구조를 따랐습니다. 클라이언트에서 HTML을 달라고 서버에게 HTTP 규격에 맞추어 요청을 보내면, 서버가 그에 맞는 HTML을 전송하는 것이 전부였습니다. 이는 애초에 웹이 대학과 연구소를 위한 학술적 정보를 저장하고 교환하기 위한 목적으로 제안되었기 때문입니다.

이러한 HTTP는 처음부터 TCP/IP 위에서 구현되도록 설계되었습니다. 지금은 TCP가 무겁고 느리다고 많이 까이지만, 당시만 해도 TCP는 연결 지향적인 특성 때문에 UDP에 비해 안정적이고 신뢰성 있는 통신을 제공했기 때문입니다.

 

게다가 대역폭(bandwidth), 흔히 이야기하는 트래픽을 최적화하는 기술인 흐름 제어(flow control), 혼잡 제어(congestion control) 기능도 기본적으로 제공했기 때문에 HTTP를 설계할 때 저렇게 복잡한 최적화 사항들까지 신경 쓸 필요가 없기도 했고요.

그러다 보니 당시 HTTP의 구조는 매우 간단했습니다. 요청 메서드 종류도 GET 한 가지뿐이었고, 헤더나 상태 코드도 없었습니다. 응답은 무조건 HTML 파일 그 자체였죠. 1991년 발표된 초창기 HTTP 사양을 지금도 확인할 수 있는데, 분량이 단 한 페이지밖에 되지 않는 것을 볼 수 있습니다.

 

아래는 HTTP/0.9 방식을 이용한 요청과 응답의 예시입니다.

```
<!-- 요청 -->

GET /mypage.html

<!-- 응답 -->
<HTML>
A very simple HTML page
</HTML>
```

## HTTP/1.1
사실 HTTP WG는 HTTP/1.0 사양을 정리하는 동시에 좀 더 표준화된 사양인 HTTP/1.1의 초안을 제작하고 있었습니다. 브라우저와 서버 개발자들은 제작 중인 초안을 참고하여 새 표준이 될 HTTP의 기능을 미리 구현해 놓았죠. 그래서 HTTP/1.1은 HTTP/1.0이 나온 지 얼마 지나지 않은 1997년에 발표될 수 있었습니다.

## HTTPS
한편으로는 HTTP의 보안을 강화한 HTTPS(HTTP Secure)가 이맘때 등장했습니다. HTTP 그 자체는 암호화되지 않은 텍스트로만 통신하기 때문에, 중간에 누군가가 통신 내용을 가로채거나 사용자의 정보를 탈취할 수 있다는 문제점이 있었거든요.

 

 

이를 방지하기 위해서는 HTTP 통신에 신뢰성과 무결성을 추가할 필요가 있었습니다. HTTPS는 이 문제를 대화 상대가 서로 자신이 신뢰할 수 있음을 증명하는 인증서를 사용하고, 통신 내용은 SSL(Secure Socket Layer) 또는 TLS(Transport Layer Security)라는 프로토콜로 암호화하는 방식으로 해결했죠.

 

SSL은 1994년 넷스케이프에서 최초로 개발한 보안 프로토콜로, 1996년 IETF(국제 인터넷 표준화 기구)에서 표준화되었습니다. 하지만 넷스케이프가 1999년 SSL 프로토콜 통제권을 IETF로 넘기면서 이름이 TLS로 바뀐 상태입니다. 따라서 현재는 TLS로 부르는 것이 맞지만, 아직도 두 프로토콜 이름을 모두 쓰는 편입니다.

 

이러한 HTTPS 통신에서 서버와 클라이언트는 서로를 신뢰할 수 있는 상대로 확인하기 위해 인증서를 이용한 비대칭 키 암호화 방식을 사용하는데, 핸드셰이크 과정을 여기에 적기에는 좀 복잡하다 보니 간단하게 비대칭 키 암호화를 이용해 대칭 키를 교환하는 방식 정도로만 설명하고 관련 자료를 링크로 걸겠습니다.

## RESTful

기존의 웹은 주로 클라이언트 측의 요청에 따라 서버가 완성된 HTML 파일을 만들어 제공하는 것이 기본이었습니다. 하지만 서버와 서버 간의 통신의 경우에는 데이터만 주고받을 수 있는 API가 필요했는데 여기에 대한 표준이 없었죠.


당시 HTTP가 웹에서 사용되는 표준 프로토콜이었기 때문에, HTTP를 기반으로 웹의 장점을 최대한 활용할 수 있는 아키텍처로 REST(Representational State Transfer)가 제안되었습니다. REST는 HTTP의 메서드를 활용하여 CRUD(Create, Read, Update, Delete)를 구현하고, URI를 통해 자원을 명시하는 등 HTTP 통신의 특성을 최대한 활용하는 아키텍처입니다.


이맘때쯤 XML이나 JSON 같은 데이터 포맷이 등장하고, 웹 브라우저에서도 비동기로 서버에 요청을 보낼 수 있는 기술인 AJAX(Asynchronous JavaScript and XML)가 보편화되면서 REST 구조를 기반으로 한 웹 서비스들이 각광받게 됩니다.


## HTTP/2

HTTP/1.1이 발표된 1997년 이후로 HTTP는 꾸준히 확장되었고, 그 사이 웹은 더욱 복잡해졌습니다. 그러다 보니 HTTP/1.1만으로는 극복할 수 없는 한계점이 점점 드러나기 시작했죠.

 

우선 헤더의 중복입니다. HTTP/1.1에 다양한 기능이 추가되면서 헤더에도 많은 메타 데이터가 담기게 되었습니다. 하지만 매 요청마다 헤더를 중복해서 전송해야만 했는데, 이것이 굉장한 낭비로 이어졌죠. 심지어 전송하려는 값보다 헤더의 크기가 더 큰 경우도 있었습니다.

 

하지만 무엇보다도 가장 큰 문제는 서버가 항상 요청받은 순서대로 응답해야 하므로 발생하는 HOLB(Head-of-Line Blocking)였습니다. HTTP/1.1에서는 하나의 연결 내에서 응답 다중화(multiplexing)를 할 수 없었기 때문에 요청이 순차적으로 처리되어야 했는데, 서버가 응답 작성 중간에 문제가 생기면 후속 요청들이 전송되지 못하고 지연되는 문제가 있었던 것이죠.

 

결국 HTTP/1.1 방식에는 물리적인 TCP 연결을 여러 개 두는 방식으로 병렬 연결을 구현하게 되었습니다. 브라우저마다의 정책도 다른데 일반적으로 최대 6개의 동시 TCP 연결을 지원한다는 것으로 알려져 있죠. 하지만 이 방식 역시 임시적인 해결책일 뿐 HTTP/1.1의 HOLB를 해결할 수 있는 해결책은 아니었습니다.

 

이 외에도 요청 별 우선순위를 지정할 수 없고, 클라이언트 기반 통신이기 때문에 서버에서 클라이언트 측으로 데이터를 전송할 수 있는 기능이 없다는 등의 문제가 있었습니다.

 

HTTP/2는 이러한 한계를 극복하기 위해 2015년 국제 표준으로 등장했습니다.



우선 HTTP/2는 SPDY라는 프로토콜을 기반으로 동작합니다. SPDY는 HTTP/1.1의 잘 알려진 성능 제한 사항을 해결하여 웹 페이지의 로드 대기 시간을 줄이는 것을 목표로 구글에서 개발하고 2009년 중반에 발표한 프로토콜입니다. 때문에 HTTP/2는 HTTP over SPDY라는 이름으로도 불립니다.
![](https://velog.velcdn.com/images/qorjiwon/post/5ce25bbb-6b87-4374-9735-dc470362f3d2/image.png)

 

이러한 HTTP/2는 기존 프로토콜과 호환성을 유지하면서, HTTP/1.1의 문제를 해결하기 위해 여러 특징을 가지고 있습니다.

## HTTP/3



---

### 📌 Reference  

- [MDN HTTP 진화](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP)
- [[요즘IT] 웹 개발자라면 알고 있어야 할 HTTP의 진화 과정](https://yozm.wishket.com/magazine/detail/1686/)
- [Introduction to HTTP/2](https://web.dev/performance-http2/)